<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.69.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>跨Account 授权S3访问的三种方式&nbsp;&ndash;&nbsp;94xychen&#39;s Blog</title><link rel="stylesheet" href="/css/core.min.46d2a3ccad11dffb6ac83d03ce2866718e13da7e9aef15850af525740c1815eab3eebde42e89da64c83b798a4b37f0f5.css" integrity="sha384-RtKjzK0R3/tqyD0DzihmcY4T2n6a7xWFCvUldAwYFeqz7r3kLonaZMg7eYpLN/D1"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="跨Account 授权S3访问的三种方式" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/images/logo.png" alt /><span class="site name">94xychen's Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="https://github.com/chenxiyu"target="_blank"><i class="fab fa-github"></i></a></nav></div></span></div><div class="site slogan"><span class="title">Digging Deeper</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">跨Account 授权S3访问的三种方式</h1><p class="article date">Thursday, February 6, 2020</p></section><article class="article markdown-body"><p>在这篇文章中, 我们整理一下跨Account 授权S3 访问的三种方式. 他们分别是, Bucket policy, Cross Account role 和 S3 ACL.</p>
<p>前两种其实前面讲过的Resource based policy 和 Identity based policy, 也是跨Account授权访问其他种类resource可以用到的通用方法, 最后一种S3 ACL 是S3特殊的一种授权方式, 在前两种能够达成目的的情况下, AWS 推荐使用前两种方式, S3 ACL已经被AWS标记成了老旧的方式(legacy way), 但是, 如果你已经使用了ACL 并且它工作良好, 那你也没有必要花精力将它改到Bucket policy上来. 那么接下来我们就一起看一下这三种授权方式的异同吧.</p>
<h2 id="s3-acls"><strong>S3 ACLs</strong></h2>
<h3 id="s3-acls-是什么"><strong>S3 ACLs 是什么?</strong></h3>
<p><strong>一个</strong> S3 ACL 是一个附加在S3 Object 或者S3 Bucket上的一个子资源(sub-resource). 它定义了哪个AWS account 或者group 能够有权限访问这个Bucket/Object, 并且它还会定义权限类型(读、写 等等), 当我们创建一个Bucket 或者Object 的时候, AWS S3 会创建一个相对应的默认ACL, 这个默认的ACL赋予资源的所有者所有权限.</p>
<h3 id="s3-acls-如何配置"><strong>S3 ACLs 如何配置?</strong></h3>
<p>S3 ACLs 的配置如下图所示, 只需要提供Account Canonical ID(理解为它等同于Account ID)、配置相关权限的授权就可以了:
<img  src="/images/three-way-to-access-s3-bucket-acrossing-accounts/1.png"
        alt="ACLs configure console"/></p>
<h3 id="s3-acls-与其他两种方式有何异同"><strong>S3 ACLs 与其他两种方式有何异同?</strong></h3>
<ul>
<li><strong>作用域</strong></li>
</ul>
<p>根据它的特性, 它与其他两者最主要的区别是它既可以附着在Bucket 上, 也可以附着在Object上, 而通过Bucket policy 和Identity based policy 来限制Object的访问的话, 只能将需要限制的Objects 写到policy的Resource字段中, 而这些policy 最终还是附着在Bucket/Identity 上面的.</p>
<ul>
<li><strong>Object的访问权限.</strong></li>
</ul>
<p>如果我们通过S3ACL 授权其他的Account 来访问, 那么其他Account 的用户在该Bucket 里面创建的Object 的权限就只有Owner(默认情况下), 即使你是Bucket 的owner, 你依然没有任何权限访问别人创建的Object 除非创建者显示的赋予你(Bucket owner)权限.</p>
<p><strong>S3 ACLs总结:</strong> S3 ACLs 可以应用在Bucket 上也可以应用在Object上来跨Account 授权, 使用ACLs 授权所创建的Object 将默认只属于创建者, 即使是Bucket owner 也没有权限访问. S3 ACLs 是一种legacy的授权方式. 其授权访问方式如下图所示:
<img  src="/images/three-way-to-access-s3-bucket-acrossing-accounts/3.png"
        alt="ACLs"/></p>
<h2 id="bucket-policy"><strong>Bucket Policy</strong></h2>
<p>Bucket Policy 就是附着在Bucket上的Resource-based policy, 我们可以通过如下代码跨Account 授权:</p>
<pre><code>{
    &quot;Version&quot;: &quot;2012-10-17&quot;,
    &quot;Statement&quot;: [
        {
            &quot;Sid&quot;: &quot;Allow xxxxx account&quot;,
            &quot;Effect&quot;: &quot;Allow&quot;,
            &quot;Principal&quot;: {&quot;AWS&quot;: &quot;1111111111&quot;},
            &quot;Action&quot;: &quot;s3:PutObject&quot;,
            &quot;Resource&quot;: &quot;arn:aws:s3:::examplebucket/*&quot;
        }
}
</code></pre>
<p>Principal 中既可以写{&ldquo;AWS&rdquo;:&ldquo;1111111111&rdquo;}, 也可以写{&ldquo;AWS&rdquo;: &ldquo;arn:aws:iam::1111111111:root&rdquo;}, 这都是指代某个Account, 特别是后面这个写法, 很多人理解成某个Account的root 用户, 这种理解是不对的, 这代表着某个Account.</p>
<p>和ACLs 类似,  如果通过上述代码授权跨Account的访问, 那么(默认情况下)Object的权限将只属于Object的创建者, 即使Bucket Owner也没有权限去访问这种Object, 但是, 在使用ACL授权的情况, 这种状况似乎是无解的,出发创建者授权给Bucket owner, 但是, 在使用Bucket policy授权时, 我们作为Bucket owner是可以采取一定的措施来避免这种情况发生的:</p>
<pre><code>{
  &quot;Version&quot;: &quot;2012-10-17&quot;,
  &quot;Statement&quot;: [
    {
      &quot;Sid&quot;: &quot;Allow xxxxx account&quot;,
      &quot;Effect&quot;: &quot;Allow&quot;,
      &quot;Principal&quot;: {
        &quot;AWS&quot;: &quot;1111111111&quot;
      },
      &quot;Action&quot;: &quot;s3:PutObject&quot;,
      &quot;Resource&quot;: &quot;arn:aws:s3:::examplebucket/*&quot;
    },
    {
      &quot;Sid&quot;: &quot;Deny Object that not grant permission to bucket owner&quot;,
      &quot;Effect&quot;: &quot;Deny&quot;,
      &quot;Principal&quot;: {
        &quot;AWS&quot;: &quot;1111111111&quot;
      },
      &quot;Action&quot;: &quot;s3:PutObject&quot;,
      &quot;Resource&quot;: &quot;arn:aws:s3:::examplebucket/*&quot;,
      &quot;Condition&quot;: {
        &quot;StringNotEquals&quot;: {
          &quot;s3:x-amz-acl&quot;: &quot;bucket-owner-full-control&quot;
        }
      }
    }
  ]
}
</code></pre>
<p>我们可以设置一个拒绝授权的条件: 如果不给Bucket Owner 赋予full access 那么就拒绝这次请求.</p>
<p><strong>总结:</strong>  和ACLs相比, Bucket policy 只能应用在Bucket上, 但是可以通过设置具体资源的方式来限制Object 的访问, 与使用ACLs授权相同, 使用bucket policy 授予其他Account权限, 默认情况下Object只属于创建者, 但是Bucket policy 可以设置“如果不赋予Bucket Owner 所有权的话, 就拒绝”的policy. 起授权访问图示如下图:
<img  src="/images/three-way-to-access-s3-bucket-acrossing-accounts/2.png"
        alt="Bucket Policy"/>{:height=&quot;100px&rdquo; width=&quot;400px&rdquo;}</p>
<h2 id="cross-account-role"><strong>Cross Account Role:</strong></h2>
<p>cross Account role 的方式就是在资源所在的Account中创建一个用来访问资源的role, 并且允许Account A中的Principal 来Assume, Account A中的principal 通过assume 到这个role上来获取访问S3 bucket 的权限. 这里对S3资源的授权本质就是Identity-based policy.</p>
<p>使用这种方式, Object的所有权还是在资源所在的Account 里面, 因为创建Object的是那个被Assume的role而已.
其授权访问图示如下图:
<img  src="/images/three-way-to-access-s3-bucket-acrossing-accounts/4.png"
        alt="Cross Account Role"/></p>
<p><strong>最后, 至于以上三种方式何时何地使用完全取决与你自己的使用场景, 依据三种方式的特性具体情况具体分析.</strong></p>
</article><section class="article labels"><a class="category" href=/categories/aws-sap/>AWS SAP</a><a class="tag" href=/tags/aws/>AWS</a><a class="tag" href=/tags/s3/>S3</a><a class="tag" href=/tags/permissions/>Permissions</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/durability-and-availability/"><span class="iconfont icon-article"></span>Durability 和 Availability</a></p><p><a class="link" href="/posts/introduction_to_concurrency_models_with_ruby_part_ii/"><span class="iconfont icon-article"></span>Ruby 并发模型介绍 第二部分 [译]</a></p></section><section class="article discussion"><div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "chenxiyu" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 94xychen.</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://gohugo.io" 
        target="_blank" rel="noopener noreferrer">Hugo</a><span>&nbsp;&amp;&nbsp;</span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank" rel="noopener noreferrer">Notepadium</a></p></div>
</section>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-158590129-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
<script src="https://kit.fontawesome.com/47f47be57a.js" crossorigin="anonymous"></script>
</body>

</html>